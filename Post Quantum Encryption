	using System;
using System.Security.Cryptography; using System.IO;
using System.Windows.Forms; using System.Collections.Generic; using System.Linq;
using System.Text; using System.Drawing;
using System.ComponentModel;

using System.Data;
using System.Threading.Tasks; namespace QuickMixCounter
{
public partial class Form1 : Form
{
public Form1()
{
InitializeComponent();
}

//A_In: Array of Word; A_Out: Array of byte;
//var
//A, B, C, E:Array of byte; //dAta FFot Mat SWich
//lenfile:integer;
//i:integer;
//j,n:integer;
//U:cardinal;
//d:byte ;
//C0,C1,Count:integer;
//FName:string;
//tempS:string;

public static byte ReadN(long Ui, byte L, byte[] B)
{
// procedure for reading a return number of length L bits
// from array B[ ] from position Ui
// Required: either dynamic array or index 0..n long i, k;
byte ms; byte D; int wd;
if (!(0 < L && L < 8)) { MessageBox.Show("Error: readN L is no range"); }; // exit if data length is incorrect
Ui--;	// converting position to bit index
k = Ui / 8;		// calculate the byte index in the array i = Ui / 7;	// number of shifts
// get the most significant bits
if ((i + L) > 8) { wd = B[k + 1] * 256; } else { wd = 0; }; wd |= B[k];	// combine two bytes
D = (byte)(wd >> (byte)i);	// shift the number
// forming a mask based on data length
ms = 0;
for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); } return (byte)(D & ms);	// masking extra bits
}
public static void AppendN( byte D, byte L, int Ui, byte[] B )
{
// procedure for adding a number D of length L bits
// to array "B" from position U bits int k=0; int i;
byte ms=0; int wd;
if (!(0 < L && L < 8))
{ MessageBox.Show("Error: readN L is no range"); } // exit if data length is incorrect for (i = 1; i < (L + 1); i++) { ms = (byte)(ms + ms + 1); };
D = (byte)(D & ms);	// masking extra bits i= Ui & 7;	// number of shifts

wd = D;
wd <<= i;	// we get shifted data Ui += L;
k= ((Ui-1) / 8) + 1; // calculate the new length of the array
Array.Resize<byte>(ref B, k + 1); // setting the length of the array, counting from 0! if (i + L > 8) {
i = B.Length - 1;
// adding a number to an array
B[i] = (byte)(B[i] | (0xFF & ((byte)(wd >> 8))));
B[i - 1] = (byte)(B[i - 1] | ((byte)(0xFF & (byte)wd)));
} else
{
i = B.Length - 1;
// adding a number to an array
B[i] = (byte)(B[i] | (byte)(0xFF & (byte)(wd)));
}
}
private void Button1_Click(object sender, EventArgs e)
{
using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Data File")))
using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save as Reduced Data File"))) using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save DNA Data File")))

{
byte[] b = new byte[8]; ulong A;
byte c;
int readLen; int i = 0;
while ((readLen = fs.Read(b, 0, 8)) > 0)
{
A = System.BitConverter.ToUInt64(b, 0);
/*Block this way XOR and ROR64	*/ ulong v = MCDE.TransposeBitMatrix(A);
/*Block this way XOR and ROR64	*/ A = v;
b = System.BitConverter.GetBytes(A); fs1.Write(b, 0, 7); // One stream of information
c = b[7];
fs2.WriteByte(c); // into another DNA stream
}
}
MessageBox.Show("OK");
}
private void Button2_Click(object sender, EventArgs e)
{
using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open as Reduced Data File"))) using (FileStream fs1 = File.OpenRead(MCDE.OpenDialog("Open as DNA Data File"))) using (FileStream fs2 = File.OpenWrite(MCDE.SaveDialog("Save as Data File")))
{
byte[] b = new byte[8]; ulong A;
byte c;
int readLen; int i = 0;
while ((readLen = fs.Read(b, 0, 7)) > 0) // Read Reduced Data 7 byte
{

c = (byte)fs1.ReadByte();// Read DNA Data 1 byte b[7] = c;
A = System.BitConverter.ToUInt64(b, 0);
/*Block this way XOR and ROR64	*/ ulong v = MCDE.TransposeBitMatrix(A);
/*Block this way XOR and ROR64	*/ A = v;
b = System.BitConverter.GetBytes(A); fs2.Write(b, 0, 8); // Recovered data

}
}
MessageBox.Show("OK");
}
private void Button3_Click(object sender, EventArgs e)
{

//uint w=Convert.ToUInt32(textBox1.Text);
//w=MCDE.ROR32(w, 1);
//textBox1.Text = Convert.ToString(w);
}
private void button10_Click(object sender, EventArgs e)
{
// Read file 1 as a sequence of matrices
//string s1 = MCDE.OpenDialog();
//string s2 = MCDE.SaveDialog();
//string s3 = MCDE.SaveDialog();
//using (var reader = new BinaryReader(File.Open(s1, FileMode.Open)))
{
//Loop through each 8 bytes in the file
//for (int i = 0; i < reader.BaseStream.Length; i += 8)
//{
// //Create an array to store the 8 bytes of a matrix
// byte[] b = new byte[8];
// //Read the next 8 bytes from the file into the array
// for (int j = 0; j < b.Length; j++)
//	b[j] = reader.ReadByte();
// //Perform a transpose of each matrix
// //TransposeMatrix(b);

// //Save first 4 bytes of each matrix to file 2
// using (var writer2 = new BinaryWriter(File.Open(s2, FileMode.Append)))
{ writer2.Write(b, 0, 1); }
// //Save remaining 4 bytes of each matrix to file 3
// using (var writer3 = new BinaryWriter(File.Open(s3, FileMode.Append)))
{ writer3.Write(b, 1, 7); }
//}
}
//Function to perform transpose on an 8x8 bit matrix stored in an array of bytes b[8] private static void TransposeMatrix(byte[] b) {	byte temp;	for (int i=0;i<4;i++)	{	int k=7-i; temp=b[i];	b[i]=b[k];	b[k]=temp;	}}
}
private void button4_Click(object sender, EventArgs e)
{
string s = MCDE.OpenDialog("Open Data File"); string s1 = MCDE.SaveDialog("Save Cript Data File"); byte[] b = new byte[512];

int i = 0; do
{
b = MCDE.ReadBlockFromFile(s, i*512, 512); MCDE.MixByteArr512(b);// can you give 2 keys
//MCDE.UnMixByteArr512(b);// can you give 2 keys MCDE.WriteBlockToFile(s1, b, i*512, 512);
i++;
}
while (b.Length == 512); MessageBox.Show("OK");
}
private void button3_Click_1(object sender, EventArgs e)
{
string s = MCDE.OpenDialog("Open Data File"); string s1 = MCDE.SaveDialog("Save Cript Data File"); byte[] b = new byte[512];
int i = 0; do
{
b = MCDE.ReadBlockFromFile(s, i * 512, 512);

MCDE.MixByteArr512(b);// can you give 2 keys
//MCDE.UnMixByteArr512(b);// can you give 2 keys MCDE.WriteBlockToFile(s1, b, i * 512, 512);
i++;
}
while (b.Length == 512); MessageBox.Show("OK");
}
private void button11_Click(object sender, EventArgs e)
{

}
private void button12_Click(object sender, EventArgs e)
{
using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open File"))) using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save File")))
{
byte[] b = new byte[1]; ulong A;
byte c;
int readLen; int i = 0;
while ((readLen = fs.Read(b, 0, 1)) > 0) // Read Reduced Data 7 byte
{
b[0] ^= (byte)(MCDE.RndConst(314159265, 9874, 3));
fs1.Write(b, 0, 1); // Recovery data
}
}
MessageBox.Show("OK");
}
private void button11_Click_1(object sender, EventArgs e)
{
using (FileStream fs = File.OpenRead(MCDE.OpenDialog("Open File"))) using (FileStream fs1 = File.OpenWrite(MCDE.SaveDialog("Save File")))
{

byte[] b = new byte[1]; ulong A;
byte c;
int readLen; int i = 0;
while ((readLen = fs.Read(b, 0, 1)) > 0) // Read Reduced Data 7 byte
{
i--;
b[0] ^= (byte)(MCDE.RndConst((uint)(314159265 + b[0]+i), (uint)(9874+i), 3)); fs1.Write(b, 0, 1); // Recovery data
}
}
MessageBox.Show("OK");

}
}

}
// Array.Reverse(people, 1, 3);
//uint[] uints = new uint[Mb.Length];
//string s = Convert.ToString(Fost);
//MessageBox.Show(s);



using System;
using System.Collections.Generic; using System.Linq;
using System.Text;
using System.Threading.Tasks; namespace NaVeOl_Cripto
{
internal class Class1
{
}
}
….……………………………………………………………………………………………………………………………………………………….
this.checkBox1.Text = "Use file-password"; this.checkBox1.UseVisualStyleBackColor = true; this.checkBox1.Visible = false;
//
// checkBox2
//
this.label1.Size = new System.Drawing.Size(92, 17); this.label1.TabIndex = 2;
this.label1.Text = "Configuration";
//
// label2
//
this.label2.Size = new System.Drawing.Size(98, 13); this.label2.TabIndex = 4;
this.label2.Text = "Directory Eco Input";
//
// pictureBox1
//
this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon"))); this.Name = "FormConfig";

this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen; ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit(); ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
 	((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).EndInit();	


partial class Form1
{
/// <summary>
/// Required constructor variable.
/// </summary>
private System.ComponentModel.IContainer components = null;
/// <summary>
/// Release all used resources.
/// </summary>
/// <param name="disposing">true if the managed resource is to be deleted; otherwise false.</param>
protected override void Dispose(bool disposing)
{
if (disposing && (components != null)) base.Dispose(disposing);
}
#region Code, automatically created by the Windows Form Designer
/// <summary>
/// Required method to support the constructor — do not change
/// the contents of this method using the code editor.
/// </summary>
private void InitializeComponent()
{
this.label1.TabIndex = 6; this.label1.Text = "Coordinates"; this.label1.Visible = false;
//
// textBox1
//
this.dataGridView1.Size = new System.Drawing.Size(406, 198); this.dataGridView1.TabIndex = 16;
this.dataGridView1.Visible = false;

this.dataGridView1.CellDoubleClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellDoubleClick);
this.dataGridView1.ColumnWidthChanged += new System.Windows.Forms.DataGridViewColumnEventHandler(this.dataGridView1_ColumnWidthChang ed);

//
// contextMenuStrip1
// this.clearToolStripMenuItem});
this.contextMenuStrip1.Name = "contextMenuStrip1"; this.contextMenuStrip1.Size = new System.Drawing.Size(159, 48);
//
// filesToolStripMenuItem
//
this.statusStrip1.TabIndex = 21; this.statusStrip1.Text = "statusStrip1"; this.statusStrip1.Visible = false;

//
// label4
//
this.progressBar1.Name = "progressBar1"; this.progressBar1.Size = new System.Drawing.Size(288, 12); this.progressBar1.TabIndex = 23;
//
// pictureBox9
//
this.pictureBox6.TabIndex = 17; this.pictureBox6.TabStop = false; this.pictureBox6.Visible = false; this.pictureBox6.MouseDown += new
System.Windows.Forms.MouseEventHandler(this.pictureBox6_MouseDown); this.pictureBox6.MouseUp += new
System.Windows.Forms.MouseEventHandler(this.pictureBox6_MouseUp);
//
this.RightToLeft = System.Windows.Forms.RightToLeft.No;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen; this.Text = "Naveol Eco- zero user license";
this.Resize += new System.EventHandler(this.Form1_Resize); this.menuStrip1.ResumeLayout(false);
 	this.menuStrip1.PerformLayout();	

using System; using System.Data;
using System.Diagnostics; using System.Drawing; using System.IO;
using System.Linq;
using System.Windows.Forms; using static NaVeOl_Cripto.MCDE; namespace NaVeOl_Cripto
{
public partial class Form1 : Form
{

public Form1()
{
InitializeComponent(); this.Height = 121;
this.Width = 320; InitializeDataTable(dataTable);
// check (ID ?) exit
if (!System.IO.File.Exists("id.ini")) // // Error file-id is missing
{ Application.Exit(); };
if (!System.IO.File.Exists("serial.ini")) // Error serial is missing
{ Application.Exit(); };
if (!Verify.SN_ID_DemoChecker()) { Application.Exit(); };
// check (LS ?) demo
MCDE.GlobalVariable.demoVer = !Verify.LS_SN_RealizeChecker(); if (MCDE.GlobalVariable.demoVer)
{ this.Text = "NaVeOl Eco - demo version"; } else { this.Text = "NaVeOl Eco Professional"; }
}
public bool TrEnableKey = false; public byte[] Key5 = new byte[512];

public byte[] StatKey5 = new byte[512]; public byte[] HashKey = new byte[512]; public static long percentMax = 0;//*** public long percentValue = 0;
Stopwatch stopwatch = new Stopwatch();
#region Click the buttons Green Red Yellow Gray Blue private void pictureBox1_Click(object sender, EventArgs e)
{
Cursor.Current = Cursors.WaitCursor; GetAllFilesFromMultiselect(); stopwatch.Start();
for (int i = 0; i < stringListFile.Length; i++)
// sorting through all the elements stringListFile - full path
//porn elements correspond to them stringListFileDistant -relative path
{ EcoIn(i); } stopwatch.Stop();
// Cleaned and updated the "explorer"
// just cleared the table and lists and selected clear_TableListFiles_Selected(); dataTable.Clear();
dataGridView1.DataSource = FillDataTable(GlobalVariable.currentDirectory, dataTable); Cursor.Current = Cursors.Default;
MessageBox.Show("Time is: " + Convert.ToString(stopwatch.Elapsed)); stopwatch.Reset();
}
private void pictureBox2_Click(object sender, EventArgs e)
{
Cursor.Current = Cursors.WaitCursor; GetAllFilesFromMultiselect(); stopwatch.Start();
for (int i = 0; i < stringListFile.Length; i++)
{ Eco_Out(i); } stopwatch.Stop();
// Cleared and updated the "explorer"
// just cleared the table and lists and selected clear_TableListFiles_Selected(); dataTable.Clear();
dataGridView1.DataSource = FillDataTable(GlobalVariable.currentDirectory, dataTable); Cursor.Current = Cursors.Default;
MessageBox.Show("Time is: " + Convert.ToString(stopwatch.Elapsed)); stopwatch.Reset();
}
private void pictureBox3_Click(object sender, EventArgs e)
{
HideShowKeyForm(); dataGridView1.Visible = false;
}
private void pictureBox5_Click(object sender, EventArgs e)
{
MessageBox.Show("NaVeOl Eco is a system data encoding method that uses the \"8(to)7\" " + "the security and confidentiality of your confidential information.\r\n\r\n" +
"In general, NaVeOl Eco is the latest, reliable and effective method of encoding and " + "protecting confidential data.", "Information about NaVeOl Eco");
}
private void pictureBox4_Click(object sender, EventArgs e)
{
FormConfig frm2 = new FormConfig();

frm2.ShowDialog(); // Launch Form2
}
#endregion #region Interface
#region Click on the additional buttons
private void pictureBox7_Click(object sender, EventArgs e)
{
if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
{
string selectedPath = folderBrowserDialog.SelectedPath;
////Moving to the designated directory ***********
//update the current directory GlobalVariable.currentDirectory = selectedPath; dataTable.Clear();
//// load catalog
dataGridView1.DataSource = FillDataTable(selectedPath, dataTable);
}
}
private void pictureBox9_Click(object sender, EventArgs e)
{
TrEnableKey = CheckFillingKeyForm(); if (TrEnableKey) // unvisible
{
HideShowKeyForm(); this.Height = 341;
this.Width = 422; dataGridView1.Visible = true; pictureBox8.Visible = true; label5.Visible = true;
dataGridView1.DataSource = FillDataTable("C:\\", dataTable); #region Настройка таблицы dataGridView1.Columns[0].HeaderText = ""; dataGridView1.Columns[5].Visible = false; dataGridView1.Columns[6].Visible = false;
#endregion
}
}
#endregion
#region Move Buttons
private void pictureBox1_MouseDown(object sender, MouseEventArgs e)
{
#endregion #endregion

private void textBox1_TextChanged(object sender, EventArgs e)
{
label1.Text = "PassWord " + Convert.ToString(textBox1.Text.Length) + " characters";
}
#region Menu connection with buttons
private void encodeToolStripMenuItem_Click(object sender, EventArgs e)
{
pictureBox1_Click(null, null); #endregion

/// <summary>
/// Checking the filling in of the password form fields

/// and check for errors
/// </summary>
private bool CheckFillingKeyForm()
{
//Check that all fields are filled in correctly bool trig = true;
if (textBox1.Text.Length < 8)// The error is less than 8 characters in the password
{
trig = false;
MessageBox.Show("You must enter a password of at least 8 characters");
}
if (textBox2.Text.Length == 0)//The error is 0 characters in the password
{
trig = false;
MessageBox.Show("You must enter address a password file");
}
if (!System.IO.File.Exists(textBox2.Text)) // The error file is empty
{
trig = false;
MessageBox.Show("Error password file address"); return trig;
}
/// <summary>
/// Turns the password file into a 512 Buff key
/// </summary>
private void Key512FromFilePwd()
{
using (FileStream fs = System.IO.File.OpenRead(textBox2.Text))//the key file was turned into a key array Buff
{
for (int i = 0; i < 512; i++) { Buff[i] = 0; };//Cleared
while (fs.Read(Data, 0, 512) > 0)// we read in blocks of 512 bytes to the end of the file
{
for (int i = 0; i < 512; i++) { Buff[i] += Data[i]; };//Put all the arrays into one
}
}// ++ Buff
}
/// <summary>
///All passwords are User, file, ID, and in the future, S/N are converted into one key per 512
/// </summary>
private void ConsolidationToKey5()
{
// !!! Here all keys are static !!! ***
// finding the HASH of the key file
Hash = Files.FileToMD5(textBox2.Text);//received a HASH of 32 bytes++
HashKey = MCDE.Keys.StrechArray_byte512(Hash);// let's stretch the HASH to 512 bytes ++
Key512FromFilePwd();// Turning the Key file into a Buff[] 512 bytes
for (int i = 0; i < 512; i++) { HashKey[i] ^= Buff[i]; } // ++let's put a Buff on the HashKey
// .. finding the static key
StatKey5 = Randomize.RndConst1(HashKey[78], 512);//
//////}
// We stretch the password to a large key
Key5 = MCDE.Keys.Pas_strechToArray512(textBox1.Text);
// We knock everything into one array for (int i = 0; i < 512; i++)
{
Key5[i] = (byte)(Key5[i] ^ StatKey5[i] + (HashKey[i] + 1));

}
////Explanation of key operations:
//// Hash->HashKey(Buff)->HashKey
////   file->Buff
////   StatKey5
//// Key5(StatKey5, HashKey)->Key5
}
/// <summary>
/// Checking the form completion
/// and based on user-entered data
/// /// creating the key KEY5
/// </summary>
private void CheckFormAndMakeKey5()
{
TrEnableKey = CheckFillingKeyForm(); // checking the form completion
//TrEnableKey = trig; // Send to the Global Variable
// result of filling out the form if (TrEnableKey)//If the form is filled out correctly
{
ConsolidationToKey5(); //We collect the Password, password file, ID and create a Key(512)
from it
}
}
label1.Visible = !label1.Visible; label2.Visible = !label2.Visible; label3.Visible = !label3.Visible; textBox1.Visible = !textBox1.Visible; textBox2.Visible = !textBox2.Visible; pictureBox6.Visible = !pictureBox6.Visible; pictureBox7.Visible = !pictureBox7.Visible; pictureBox9.Visible = !pictureBox9.Visible; statusStrip1.Visible = !statusStrip1.Visible; this.Height = 252;
this.Width = 412;
}
private void HideKeyForm()
{
label1.Visible = false; textBox1.Visible = false; textBox2.Visible = false; pictureBox6.Visible = false; pictureBox7.Visible = false; pictureBox9.Visible = false;
}

private void timer1_Tick(object sender, EventArgs e)
{
label4.Text = Convert.ToString(stringListFile.Length) + "select files";
}
#region Files Selecter
static readonly DataTable dataTable = new System.Data.DataTable(); string[] stringList = new string[0];
string[] stringListDistant = new string[0]; string[] stringListFile = new string[0]; string[] stringListFileDistant = new string[0]; string[] stringListDir = new string[0];
void InitializeDataTable(DataTable dataTable)

{
dataTable.Columns.Add("Ico", typeof(Image)); dataTable.Columns.Add("Name"); dataTable.Columns.Add("Ext"); dataTable.Columns.Add("Path"); dataTable.Columns.Add("Type"); dataTable.Columns.Add("Number"); dataTable.Columns.Add("Sort");
}
DataTable FillDataTable(string path, DataTable dataTable)
{
pictureBox1.Image = Resource1.a2; Image image1 = Resource1.DImg; Image image2 = Resource1.FImg; string folderPath = path;
DirectoryInfo directory = new DirectoryInfo(folderPath);
// Getting a list of folders from a folder System.IO.DirectoryInfo[] dirs = directory.GetDirectories();
// Filling the DataTable with file data foreach (DirectoryInfo file in dirs)
{
dataTable.Rows.Add(image1, file.Name, file.Extension, file.FullName, "D");
}
// Getting a list of files from a folder FileInfo[] files = directory.GetFiles();
// Filling the DataTable with file data foreach (FileInfo file in files)
{
dataTable.Rows.Add(image2, file.Name, file.Extension, file.FullName, "F");
}
return dataTable;
}//
void SelectToStringList()
{
DataGridViewSelectedRowCollection selectedRows = dataGridView1.SelectedRows;
// The user has selected rows, we will iterate over each of them foreach (DataGridViewRow row in selectedRows)
{
// In each row, select a cell in the desired column
string column1Value = row.Cells["Name"].Value.ToString();
// We will add the data to the string array Array.Resize(ref stringList, stringList.Length + 1); stringList[stringList.Length - 1] = column1Value;
}
}
void GetAllFilesFromDir(string path)
{
// Get all files in the directory and its subdirectories string[] files;
try
{
files = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
}
catch (UnauthorizedAccessException ex)
{
MessageBox.Show("Unauthorized Access !" + Convert.ToString(ex), "Exception"); goto Label1;

}
// Print the full path of each file foreach (string file0 in files)
{ // we write the source files in one list
Array.Resize(ref stringListFile, stringListFile.Length + 1); stringListFile[stringListFile.Length - 1] = file0;
// take a relative path and put it in the final list
// Find the index of the first occurrence of the substring string subString = GlobalVariable.currentDirectory;
int index = file0.IndexOf(subString); string file1;
if (index >= 0)
{ // Deleting the substring - got a relative path
file1 = file0.Remove(index, GlobalVariable.currentDirectory.Length);
// Written to the final list
Array.Resize(ref stringListFileDistant, stringListFileDistant.Length + 1); stringListFileDistant[stringListFileDistant.Length - 1] = file1;
}
}
Label1:;
}
//All files from the directory and its subdirectories
//moved to a string array
void GetOnlySelectionDirectories()
{
// Assuming the data source for dataGridView1 is a DataTable called "dataTable" DataTable dataTable = (DataTable)dataGridView1.DataSource;
// Iterate over the selected rows
foreach (DataGridViewRow selectedRow in dataGridView1.SelectedRows)
{
// Get the corresponding DataRow from the DataTable
DataRow dataRow = ((DataRowView)selectedRow.DataBoundItem).Row;
// Access the value of the "Type" column string typeValue = dataRow["Type"].ToString();
// Check if the value is "D" if (typeValue == "D")
{
// Access other column values if needed
string column1Value = dataRow["Path"].ToString(); Array.Resize(ref stringListDir, stringListDir.Length + 1); stringListDir[stringListDir.Length - 1] = column1Value;
}
}
}
//Only directories were moved from the selected one to the string array void GetOnlySelectionFiles()
{
// Assuming the data source for dataGridView1 is a DataTable called "dataTable" DataTable dataTable = (DataTable)dataGridView1.DataSource;
// Iterate over the selected rows
foreach (DataGridViewRow selectedRow in dataGridView1.SelectedRows)
{
// Get the corresponding DataRow from the DataTable
DataRow dataRow = ((DataRowView)selectedRow.DataBoundItem).Row;
// Access the value of the "Type" column string typeValue = dataRow["Type"].ToString();
// Check if the value is "D"

if (typeValue == "F")
{
//Take the original full path
string column1Value = dataRow["Path"].ToString();
//We take the final relative path
string column1ValueDist = dataRow["Name"].ToString();
// we put it in the original list
Array.Resize(ref stringListFile, stringListFile.Length + 1); stringListFile[stringListFile.Length - 1] = column1Value;
//we put it in the final list
Array.Resize(ref stringListFileDistant, stringListFileDistant.Length + 1); stringListFileDistant[stringListFileDistant.Length - 1] = column1ValueDist;
}
}
}
//Only Files were moved from the selected one to the string array void GetAllFilesFromMultiselect()
{
GetOnlySelectionFiles(); // Took the selected files from the root GetOnlySelectionDirectories();//Took the selected directories foreach (string str in stringListDir)
{
GetAllFilesFromDir(str);
}
}
#endregion
private void EcoIn(int index /* stringListFile & stringListFileDistant*/)
{
//EnCript(); CheckFormAndMakeKey5(); if (TrEnableKey)
{
HideKeyForm();
//We find the full addresses of the source and 2 destination files bool B = true;
long FSize;
string s = stringListFile[index]; /// SOURCE file, relative path if (s == "") { B = false; };
// cut the file ******
// and replace the directory with a remote one
string s1 = GlobalVariable.directoryEco + stringListFileDistant[index] + ".nvl"; s1 = s1.Replace("\\\\", "\\");
if (B)
{
FSize = Files.FileResize(s);// // adding a tail + 512 bytes = rnd + size Source File)
// Opening two files for reading and writing using (FileStream fs = System.IO.File.OpenRead(s))
{ // if there is no ECO directory, we create
if (!Directory.Exists(GlobalVariable.directoryEco))
{
Directory.CreateDirectory(GlobalVariable.directoryEco);
}
// if there is no directory for the final file in the ecosystem, we create string directoryOfDistantFile = Path.GetDirectoryName(s1);
if (!Directory.Exists(directoryOfDistantFile))
{
Directory.CreateDirectory(directoryOfDistantFile);

using (FileStream fs1 = System.IO.File.OpenWrite(s1))
{
#region Variables Encode
byte[] b = new byte[256]; // block of MicroCoding ulong i = 0;//****
int EOF; // 1 - Read // 0 - End of File byte[] K = new byte[512];//key byte[] R = new byte[512];//key
//byte[] MAT1 = new byte[128];
//byte[] MAT2 = new byte[128]; byte[] MAT = new byte[256];
//MAT2 = NaVeOl.GenMat7bit(Key5[MAT1[i++]]);
int x = Key5[Key5[0]] + Key5[Key5[5]] * Key5[Key5[8]]; MAT = NaVeOl.GenMat8bit(x & 726);
i = (ulong)x; // scrolling the key will not start from the beginning
// move on QUICKLY! we encode without the last block
//we read eight 8 bytes each (64 bit matrix) #endregion// Declaring variables
// // the block is created in MC DE.Files.File Resize in the same place, the tail
// is added first and the length of the source file is secretly inserted R = GlobalVariable.EndRndBlock;
for (int k = 0; k < Key5.Length; k++)// Fused the index and two keys
{
Key5[k] = (byte)(Key5[k] ^ R[k]);
}
percentMax = fs.Length;
// Main : CODING CORE
while ((EOF = fs.Read(b, 0, 256)) > 0) //we read 256 bytes except the End block
{
if ((fs.Position & 33554432) == 33554432)
{
progressBar1.Value = (byte)(100.0 / (percentMax) * (fs.Position + 1.0));
}
Key5[11] = (byte)(Key5[111] ^ NaVeOl.Lower());
// the slowdown of the program from version more could not be reduced #region key change each encoding block
if ((i & 1) == 0)
{// 4.5E-9 s/Mb
Key5 = NaVeOl.FreshQQKey(Key5, MAT, (int)i & 428);
}
// When decoding, the flip of the mats index is added<>Number
// // and name change to MAT1i, MAT2 i, Mate #endregion
// This Encoding 4.5E-9 s/Mb for (int j = 0; j < 256; j++)//****
{
b[j] = (byte)(b[j] ^ Key5[j]);
};	//1
	b = NaVeOl.Encoding_IQ2(b, MAT); // 6E-9 s/Mb 0.04 c / 6.775 Мб fs1.Write(b, 0, 256); // 6E-9 s/Mb
i++; // counter
}
fs1.Write(R, 0, 512); //RND(time) key to end file progressBar1.Value = 0;
}
}
/// Trim the file to the original size ***** !!!!

/// Restoring. Increased at the beginning:
//this function needs to be optimized Files.FileResize(s)
using (FileStream fsSource = new FileStream(s, FileMode.Open))
{
fsSource.SetLength(GlobalVariable.SizeSourceFile);// see of size!!!
}
}
else
{
}
}
else
{
MessageBox.Show("Press Yellow coordinates and fill out the form ");
}
}
private void Eco_Out(int index /* stringListFile & stringListFileDistant*/)
{
//If the keys are filled in: CheckFormAndMakeKey5(); if (TrEnableKey)
{
HideKeyForm();
//We find the full addresses of the 2 source and destination files bool B = true;
#pragma warning disable CS0168 // long FSize;
#pragma warning restore CS0168 // string s1, ext;
string s = stringListFile[index];// input full address s1 = s;
if (s == "") { B = false; }; // cheking ext = Path.GetExtension(s);
if (ext != ".nvl") { B = false; };// check ext 1
s = Path.ChangeExtension(s, null);// del ext 1 string pathOut = GlobalVariable.directoryEcoOut;
// we need to drop the current directory
// take the relative path and put it in the final list
// Find the index of the first occurrence of the substring string subString = GlobalVariable.currentDirectory + "\\"; int indx = s.IndexOf(subString);
string file1 = ""; if (indx >= 0)
{ // Deleting the substring - we got a relative path file1 = s.Remove(indx, subString.Length);
}
//
s = pathOut + Path.GetDirectoryName(file1) + "\\" + Path.GetFileName(file1);//got the name of the final file All!!!!
s = s.Replace("\\\\", "\\"); if (TrEnableKey)
{
if (B)
{
// Reading the Random Key from the last 512 Decoding block using (FileStream fs1 = System.IO.File.OpenRead(s1))
{



reading

byte[] buffer = new byte[512]; // 512 bytes of data
FileStream fs = new FileStream(s1, FileMode.Open, FileAccess.Read); // Open file for

fs.Seek(-512, SeekOrigin.End); // Go to the end of the file and back 512 bytes fs.Read(buffer, 0, 512); // Read 512 bytes into buffer
fs.Close(); GlobalVariable.EndRndBlock = buffer;
}

//We pull out the length of the file from the last block byte[] m = new byte[8];
for (int i = 0; i < 8; i++)
//for the inverse function, rearrange A=B^C <-> B=A^C
{
m[i] = (byte)(GlobalVariable.EndRndBlock[i * i + 7]
^ GlobalVariable.EndRndBlock[i + 87]);
};// end encoding #region
GlobalVariable.SizeSourceFile = BitConverter.ToInt64(m, 0); long Fsize = GlobalVariable.SizeSourceFile;
#endregion
using (FileStream fs1 = System.IO.File.OpenRead(s1)) // nvl
{
if (!Directory.Exists(GlobalVariable.directoryEcoOut))
{
Directory.CreateDirectory(GlobalVariable.directoryEcoOut);
}
string directoryOfDistantFile = Path.GetDirectoryName(s); if (!Directory.Exists(directoryOfDistantFile))
{
Directory.CreateDirectory(directoryOfDistantFile);
}
using (FileStream fs = System.IO.File.OpenWrite(s)) // Decoding recoverable file
{
#region Variables Decode
byte[] b = new byte[256]; // block for micro encoding ulong i = 0;// counter for key
int EOF; // 1 - reading // 0 - end of file byte[] K = new byte[512];//key
byte[] R = new byte[512];//key byte[] MAT = new byte[256]; byte[] MATi = new byte[256];
int x = Key5[Key5[0]] + Key5[Key5[5]] * Key5[Key5[8]]; MAT = NaVeOl.GenMat8bit(x & 726);
i = (ulong)x; // scrolling the key will not start from the beginning
// When decoding, the flip of the mats index is added<>Number
// // and name change to MAT1i, MAT2 i, Mate MATi = NaVeOl.MatTableReplaceIndx2Num(MAT); #endregion
R = GlobalVariable.EndRndBlock;
for (int k = 0; k < Key5.Length; k++)//
{ Key5[k] = (byte)(Key5[k] ^ R[k]); } percentMax = fs1.Length;
while ((EOF = fs1.Read(b, 0, 256)) > 0) // we read 256 bytes except the End block
{
// we read 1 byte except the End of the EOF block on the DNA will end, and 512 bytes of Random Key will remain on the RNA
// // the microscopy unit is now full




from the version

#region Key change each decoding unit
//Changing the key every block
Key5[11] = (byte)(Key5[111] ^ NaVeOl.Lower()); // slowing down the program

if ((i & 1) == 0)
{

Key5 = NaVeOl.FreshQQKey(Key5, MAT, (int)i & 428);
}
else
{
MAT = NaVeOl.FreshQMAT(MAT, Key5[i & 511]);
MATi = NaVeOl.MatTableReplaceIndx2Num(MAT);
}
#endregion
percentValue = fs1.Position;
// Change progressBar
if ((fs.Position & 33554432) == 33554432)
{
progressBar1.Value = (byte)(100.0 / (percentMax) * (fs.Position + 1.0));
}
b = NaVeOl.Decoding_IQ2(b, MATi);
// encoding
for (int j = 0; j < 256; j++)
{
b[j] = (byte)(b[j] ^ Key5[j]);
};	//1
fs.Write(b, 0, 256); // i++; //counter
}
}
}
/// Trim the file to the original size ***** !!!!
using (FileStream fsSource = new FileStream(s, FileMode.Open))
{
fsSource.SetLength(GlobalVariable.SizeSourceFile);// see of size!!!
}
}
else
{
}
}
else
{
}
}
progressBar1.Value = 0;
}
}
}


private void dataGridView1_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
{
//// This all
//// doubleClick and go to to catalog
///
object cellValue = dataGridView1.Rows[e.RowIndex].Cells[4].Value;

// change of data type
string value = cellValue.ToString();
if ((cellValue != null) && (value == "D")) // check
{ // get path
cellValue = dataGridView1.Rows[e.RowIndex].Cells[3].Value;
// change of data type value = cellValue.ToString();
// reload current directory GlobalVariable.currentDirectory = value; dataTable.Clear();
//Load catalog
dataGridView1.DataSource = FillDataTable(value, dataTable);
}
}
private void filesToolStripMenuItem_Click(object sender, EventArgs e)
{
GetAllFilesFromMultiselect();
// no select dataGridView1.ClearSelection();
// don't repeat (see uses)
stringListFile = stringListFile.Distinct().ToArray();
}
private void clearToolStripMenuItem_Click(object sender, EventArgs e)
{ // clear of table and list of select clear_TableListFiles_Selected();
}
private void clear_TableListFiles_Selected()
{ // clear of table and lists Array.Resize(ref stringList, 0);// New list
	Array.Resize(ref stringListFile, 0);// New list Array.Resize(ref stringListFileDistant, 0);//New list Array.Resize(ref stringListDir, 0);// СNew list
// no select dataGridView1.ClearSelection();
}
private void Form1_Resize(object sender, EventArgs e)
{
if (dataGridView1.Visible)
{ // dynamically link the width of the form and the tables and columns dataGridView1.Width = this.Width; dataGridView1.Columns[3].Width = this.Width -
dataGridView1.Columns[0].Width - dataGridView1.Columns[1].Width - 20;
// let's move the folder image to the size of the window if ((this.Width - 61) < 361)
{
pictureBox8.Left = 361;
label5.Location = new Point(330, label5.Location.Y);
}
else
pictureBox8.Left = this.Width - 61;
label5.Location = new Point(this.Width - 92, label5.Location.Y);
}
//dynamically linking the height of the form and the table dataGridView1.Height = this.Height - 143;
progressBar1.Location = new Point(progressBar1.Location.X, this.Height - 56);
}
dataGridView1.Columns[0].Width - dataGridView1.Columns[1].Width - 20;

}





textBox2.Text = MCDE.GlobalVariable.directoryEcoOut;
}

//private void button1_Click(object sender, EventArgs e)
//{
// Close();
//}
private void pictureBox1_Click(object sender, EventArgs e)
{
if (Directory.Exists(textBox1.Text))
{
MCDE.GlobalVariable.directoryEco = textBox1.Text;
}
if (Directory.Exists(textBox2.Text))
}
private void pictureBox2_Click(object sender, EventArgs e)
// select distention directory for ECO system
{
FolderBrowserDialog folderBrowserDialog = new FolderBrowserDialog(); folderBrowserDialog.Description = "Select directory of ECO"; folderBrowserDialog.ShowNewFolderButton = true;
if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
{
}
}

private void pictureBox2_MouseDown(object sender, MouseEventArgs e)
{
pictureBox2.Image = NaVeOl_Cripto.Resource1.h2; pictureBox1.Image = NaVeOl_Cripto.Resource1.f1;
}

private void pictureBox3_Click(object sender, EventArgs e)
{
// select destention directory for ECO Out system folderBrowserDialog.ShowNewFolderButton = true;
if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
{
textBox2.Text = folderBrowserDialog.SelectedPath + "\\"; MCDE.GlobalVariable.directoryEcoOut = folderBrowserDialog.SelectedPath + "\\";
}
 	}	

{
internal class MCDE
{
internal class Files
{
public static String OpenDialog(string Title, int p = 0)
{
using (OpenFileDialog openFileDialog = new OpenFileDialog())

}
}
/// <summary>
/// Complements the RND file to a multiplicity of 512 and
/// adds another 1 of 512 block
	/// and includes hiding the length of the source file into RND bloс.
/// A random block generates, but does not write, but stores it in a global variable
/// </summary>
/// <param name="b"></param>
/// <param name="fileName"></param>
{
// get and calculation info
FileInfo info = new FileInfo(fileName);
long size = info.Length;	// file length source GlobalVariable.SizeSourceFile = size;
long NBlocks = size / 512;	// the number of whole blocks in the file int EndTail = (int)(size - NBlocks * 512); // non-multiple 512 remainder - tail
int Tail_Add = 512 - EndTail;	// the length of the piece to add to the tail is up to a whole block



tail

//generating a tail
byte[] data = new byte[Tail_Add];	// declare an array to add up to an entire block to the

Randomize.RndTime1(data);	// generate it
// generating another 512 block to add byte[] RndKey = new byte[512]; Randomize.RndTime1(RndKey);
////split size into a byte array
byte[] SizeByte = BitConverter.GetBytes(size);
// Hiding bytes in the last block
for (long i = 0; i < SizeByte.LongLength; i++)
//for the inverse function - rearrange A=B^C <-> B=A^C
{ RndKey[i * i + 7] = (byte)(SizeByte[i] ^ RndKey[i + 87]); };
// Open the file using FileStream and specify that we want to open the file for appending. using (FileStream fs = new FileStream(fileName, FileMode.Append))
{

fs.Write(data, 0, Tail_Add);
//fs.Write(RndKey, 0, 512); /// !!!! we do not write to the source, but only to the final RNA
} // Write the bytes to the end of the file	fs.Write(data, 0, data.Length); } GlobalVariable.SizeTail = EndTail;
/// </summary>
/// <param name="b"></param>
/// <param name="fileName"></param>
/* ***Need to redo, the idea is not to touch the source file
//using System.IO;
byte[] dataArray = { 0x01, 0x02, 0x03 };
*/
public static byte[] FileToMD5(string filename)
{// Get MD5 for Eco file
using (var md5 = MD5.Create())
{
using (var stream = File.OpenRead(filename))
}
}
}

internal class GlobalVariable
{

public static bool demoVer = true;
public static string currentDirectory = @"C:\";//***** public static string directoryEco = @"C:\NaVeOl_ECO\";
public static string directoryEcoOut = @"C:\NaVeOl_ECO_out\"; public static long SizeSourceFile;
public static int SizeTail; // public static int SizeTail_Add;//
public static byte[] EndRndBlock = new byte[512];// the last random block with the size of the source file stitched into it
public static byte[] FK = new byte[256]; // Fake Array for func lower()
}
internal class Keys
{
public static byte[] StrechArray_byte512(byte[] a)
{
L[i] = (byte)((L[i - 1] ^ 715959500) * s * a[i % a_len] * i + (p + 1 + L[i - 1]) * i + y);
};
	a = Randomize.RndConst1(a[0], 512);// *** if а<8 there may be a mistake for (i = 0; i != 512; i++)
{
L[i] = (byte)(~L[i] ^ a[i]);
}
return L;
}
for (i = 0; i != (szPas - 3); i++) { L[i] = (byte)(L[i] * L[i + 1] / (L[i + 2] + 1)); } return L;
}// Streach password to 512 byte

}
internal class NaVeOl
{
public static byte Lower() // Slowing down the program in Professional -disabled
{
if (GlobalVariable.demoVer) // Demo
{
for (int i = 0; i < 256; i++)
{
#endregion
}
}
else //realise ver 2 Version 2 professional
{
//for (int i = 0; i < 256; i++)
//{
// #region //Master //K=1.23
// GlobalVariable.FK[i] = (byte)(GlobalVariable.EndRndBlock[i]
//	/ 5.15 * 9.85);//Master //K=1.23
// #endregion
// #region //Bat BAsic //K=1.6
// //for (int k = 0; k < 1; k++)
/// <summary>
/// Replace the number with its index
/// </summary>
/// <returns></returns>
public static byte[] Encoding_IQ2(byte[] data, byte[] MAT)
{
//Method encoding IQ2 input data, MATi NaVeOl

for (int i = 0; i < data.Length; i++)
{// exchange number to her index data[i] = MAT[data[i]];
};
return data;
}
/// <returns></returns>
public static byte[] Decoding_IQ2(byte[] data, byte[] MATi)
{
//Method decoding IQ2 input data, MATi NaVeOl for (int i = 0; i < data.Length; i++)
{// exchange number to her index data[i] = MATi[data[i]];
};
return data;
}
public static byte[] FreshQMAT(byte[] MAT, int varSeed)// 1.7 s/18Mb
{ // The number of fast functions of permutations needs to be greatly increased switch ((varSeed + MAT[(byte)varSeed]) & 15)
{
case 0:
Array.Reverse(MAT); case 2:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] = (byte)(MAT[i] ^ 181);
}
break; case 3:
case 5:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] = Roling.ROR_QQShift(MAT[i], 1);
}
break; case 6:
for (int i = 0; i < MAT.Length; i++)
{
case 9:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 191;
}
break; case 10:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 244;
}
break; case 11:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 111;
}
break; case 12:

for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 45;
}
break; case 13:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 14;
}
break; case 14:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 86;
}
break; default:
for (int i = 0; i < MAT.Length; i++)
{
MAT[i] += 77;
}
break;
}
return MAT;
}
public static byte[] FreshQQKey(byte[] Key5, byte[] MAT, int seed) // s/18Mb
{
Key5.Reverse();
for (int i = 0; i < 256; i++)
{
Key5[i] = (byte)(Key5[i] + Key5[i + 127] + MAT[255 - i]);
}
//
return Key5;
}

public static byte[] GenMat8bit(int seed)
{
byte[] MAT = new byte[256]; return MAT;
}//New MAT 8 bit

public static byte[] MatTableReplaceIndx2Num(byte[] MAT)//MAT any Length EnChange index<->number
{
byte[] result = new byte[MAT.Length]; internal class Randomize
{
public static byte[] RndConst1(int Seed, uint LenArray)
{
byte[] data = new byte[LenArray];
// Create a new random object with the same seed value each time. Random rand = new Random(Seed);
// Checking
if ((Seed > 65537) | (LenArray > 1000000)) { MessageBox.Show("Very big number!"); };
// Generate a random number and store it in 'previous' variable.

rand.NextBytes(data);
//byte[] data = new byte[4]; rng.GetBytes(Array);
}
/// <summary>
/// Generate Seed Random Numbers size = MaxNum+1 Only Unique Numers
{
numbers.Add((byte)i);
}
byte[] result = new byte[size];
Random random = new Random(seed); for (int i = 0; i < size; i++)
result[i] = numbers[index]; numbers.RemoveAt(index);
}
//
return result;
}//+++
}
internal class Roling
{
public static byte ROL_QQShift(byte number, int shift)
{// Do not load!!!! But it is mandatory to check shift = 1..7
//	degree, forward shift
byte bitTemplate = (byte)(((2 << shift) - 1) << (8 - shift));// transfer bit pattern byte buff = (byte)(number & bitTemplate); // Copied bits going into <-overflow
// we drive the portable part to the right, and the non-portable part to the left return (byte)((buff >> (8 - shift)) + (number << shift));
}
public static byte ROR_QQShift(byte number, int shift)
{
byte bitTemplate = (byte)((2 << shift) - 1); byte buff = (byte)(number & bitTemplate);
 	return (byte)((buff << (8 - shift)) + (number >> shift));	

The order of launching the program:
Run the program: "NaVeOl_ECO_Git\bin\Release\NaVeOl_ECO.exe " Select: "Coord's"
Enter:
"coordinates" # Any sequence of characters you play is the key # at least 8 characters
"Select coordinates file" # Any key file Click: "Ok"

Select: "Config"
Directory Eco Input: "Change or leave by default" Directory Eco Output: "Change or leave the default" Click: "Ok"
Select multiple files or directories:
Selecting a file or directory in the current Explorer window: "Select one or more files and/or directories"
# Using (shift or ctrl) and the mouse pointer
Add the selected files and/or directories to the list or clear the list: "After selecting the files, click the context menu and select:
+ add to list files
- clear list files"
Switching to another directory in the explorer window:

"Click Change Folder and select another directory" Include in the Ecosystem:
"Click In_eco"
# # the result will be found in (Directory Echo Input) Exclude from Ecosystem:
"Click Out_eco"
# # the result will be found in (Directory Echo Output)

The order of compilation of the program:
Install: "Microsoft Visual Studio Community 2022" Open: "NaVeOl_Crypto.sln"
Using: "Microsoft Visual Studio Community 2022" Compile the project: "In Realize mode"

IDE:
Microsoft Visual Studio Community 2022 Version 17.7.6 VisualStudio.17.Release/17.7.6+34221.43 Microsoft .NET Framework
Version 4.8.09037 Installed version: Community
Visual C++ 2022 00482-90000-00000-AA691
Microsoft Visual C++ 2022
ASP.NET and Web Tools 17.7.274.37181
ASP.NET and Web Tools Common Azure Tools 1.10
Provides common services for use by Azure Mobile Services and Microsoft Azure Tools. Cookiecutter 17.0.23189.3
Provides tools for searching, instantiating, and configuring templates in cookie cutter format. IncrediBuild Build Acceleration 1.6.0.2
IncrediBuild effectively reduces compilation and development times by up to 90%. Microsoft JVM Debugger 1.0
Provides support for connecting the Visual Studio debugger to JDWP compatible Java Virtual Machines
	Python с Pylance 17.0.23189.3
Provides IntelliSense, projects, templates, debugging, interactive windows and other auxiliary functions for Python developers.
Python — поддержка Django 17.0.23189.3
Пprovides templates and integration for the Django web platform. Python — profiling support 17.0.23189.3
Profiling support for Python projects.
Visual C++ for cross-platform mobile application development (Android) 17.0.33906.96 Visual C++ for cross-platform mobile application development (Android)
Visual Studio IntelliCode 2.2
Development using artificial intelligence for Visual Studio.
Visual C++ for cross-platform mobile application development (iOS) 17.0.33906.96 Visual C++ for cross-platform mobile application development (iOS)
Visual F# Tools 17.7.0-beta.23314.10+e612cf93b989503c89e3a5830090062b7ab5e143 Microsoft Visual F# Tools
The Test Adapter for Google Test 1.0
Includes Visual Studio testing tools and unit tests for Google Test. For terms of use and third-party notifications, see the extension installation directory.
Adapter of tests for Boost.Test 1.0
Allows you to use unit tests written for Boost.Test, in the Visual Studio testing tools. The Terms of Use and Notices of third parties are available in the extension installation directory.
NuGet Package Manager 6.7.0

NuGet Package Manager in Visual Studio. For more information about NuGet, see the website https://docs.nuget.org/
C# Tools 4.7.0-3.23517.17+
9d4cc0304792762c34f41cbbec67a1fcd2dc764f C# components used in the integrated development environment. Depending on the type and settings of the project, different versions of the compiler can be used.
Visual Basic Tools 4.7.0-3.23517.17+
9d4cc0304792762c34f41cbbec67a1fcd2dc764f Visual Basic components used in the integrated Development environment. Depending on the type and settings of the project, different versions of the compiler can be used.
Средства TypeScript 17.0.20829.2001 Средства TypeScript for Microsoft Visual Studio
Azure Application Service Tools, version 3.0.0 17.7.274.37181 Azure Application Service Tools, version 3.0.0
Package Structure:
NaVeOl_ECO_Git\ bin\
Debug\	# debug version upload directory Release\	# download directory of the final version
Navel_ECO.exe.config
id.ini	# user identification number license.ini # license number
serial.ini # serial number
# there is an algorithmic relationship between the user number, # serial number and license number.
NaVeOl_ECO.exe # Compiled executable file Navel_ECO.pdb
obj\# IDE directory Properties\	# IDE directory Resources\		# IDE directory Form1.cs # form 1 code
Form1.Designer.cs # form 1 constructor Program.cs # program code Resource1.Designer.cs # resource file code 1 Verify.cs # module verification id/sn/ls
MC DE.cs# module for encoding and working with files Form2.cs # program code
Form2.resx
Form2.Designer.cs # form constructor 1 NaVeOl_Cripto.csproj
.gitattributes
.gitignore NaVeOl_Cripto.csproj.user Form1.resx Resource1.resx
jj2.png	# the graphic element of the program is included in the resource file jj1.png	# the graphic element of the program is included in the resource file NaVeOl_Cripto.sln # Main project file
FImg.png			# the graphic element of the program is included in the resource file DImg.png			# the graphic element of the program is included in the resource file DImg.bmp					# the graphic element of the program is included in the resource file FImg.bmp				# the graphic element of the program is included in the resource file f1.png	# the graphic element of the program is included in the resource file f2.png	# the graphic element of the program is included in the resource file g1.png		# the graphic element of the program is included in the resource file g2.png		# the graphic element of the program is included in the resource file h1.png		# the graphic element of the program is included in the resource file

h2.png	# the graphic element of the program is included in the resource file App.config
e2.PNG	# the graphic element of the program is included in the resource file b1.PNG	# the graphic element of the program is included in the resource file b2.PNG	# the graphic element of the program is included in the resource file c1.PNG	# the graphic element of the program is included in the resource file c2.PNG	# the graphic element of the program is included in the resource file d1.PNG	# the graphic element of the program is included in the resource file d2.PNG	# the graphic element of the program is included in the resource file e1.PNG	# the graphic element of the program is included in the resource file a2.PNG	# the graphic element of the program is included in the resource file a1.PNG	# the graphic element of the program is included in the resource file Icon2.ico	# the graphic element of the program is included in the resource file Icon1.ico	# the graphic element of the program is included in the resource file


<Reference Include="System.Xml" />
</ItemGroup>
<ItemGroup>
<Compile Include="Form1.cs">
<SubType>Form</SubType>
</Compile>
<None Include="Resources\Fimg.bmp" />
<None Include="jj1.png" />
<None Include="jj2.png" />
</ItemGroup>
<ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />	

using System;
using System.Windows.Forms; namespace NaVeOl_Cripto
internal static class Program
{
/// <summary>
///
/// </summary> [STAThread]
 	static void Main()	

/// <summary>
///
/// </summary>
//

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTyped ResourceBuilder", "17.0.0.0")]
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()] [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
}

/// <summary>
/// </summary>

[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.Editor BrowsableState.Advanced)]
public static global::System.Resources.ResourceManager ResourceManager {
}

/// <summary>
///
/// </summary>

[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.Editor BrowsableState.Advanced)]
 	public static global::System.Globalization.CultureInfo Culture {	

<?xml version="1.0" encoding="utf-8"?
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
<assemblyIdentity version="1.0.0.0.0" name="MyApplication.app" />
<trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
<security>.
<requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
<!-- UAC manifest settings
If you want to change the level of Windows account control, replace the requestedExecutionLevel node with one of the following.
<requestedExecutionLevel level="asInvoker" uiAccess="false" />
<requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
<requestedExecutionLevel level="highestAvailable" uiAccess="false" />
Specifying the requestedExecutionLevel element will disable file and registry virtualisation. Remove this element if virtualisation is required by the application for backward compatibility. compatibility.
-->
<requestedExecutionLevel level="asInvoker" uiAccess="false" />
</requestedPrivileges>
<applicationRequestMinimum>
<defaultAssemblyRequest permissionSetReference="Custom" />
<PermissionSet class="System.Security.PermissionSet" version="1" Unrestricted="true" ID="Custom" SameSite="site" />

</applicationRequestMinimum>
</security>
</trustInfo>
<compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
<application>
<!-- List of Windows versions on which this application has been tested and will work. Uncomment the appropriate items to have Windows OS will automatically select the most compatible environment. -->
<!-- Windows Vista -->
<!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
<!-- Windows 7 -->
<!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
<!-- Windows 8 -->
<!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
<!-- Windows 8.1 -->
<!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
<!-- Windows 10 -->
<!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
</application>
</compatibility>
<!-- Indicates that the application supports DPI detection and will not be automatically scaled by Windows at higher
DPI values. Windows Presentation Foundation (WPF) applications support DPI detection by default, they do not need to

to specifically enable the setting to do so. For Windows Forms applications on the .NET Framework 4.6 platform that have this setting, you must
also set "EnableWindowsFormsHighDpiAutoResizing" to "true" in the app.config file.

When you do this, the application starts to take long paths into account. For more information, see https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation.-->
<!--
<application xmlns="urn:schemas-microsoft-com:asm.v3">
<windowsSettings>
<dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
<longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
</windowsSettings>
</application>
-->
<!-- Enable themes for common Windows controls and dialogue boxes (Windows XP and later) -->
<!--
<dependency>
<dependentAssembly>
<assemblyIdentity type="win32"
name="Microsoft.Windows.Common-Controls" version="6.0.0.0.0"
processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"
/>
</dependentAssembly>
</dependency>
-->
</assembly>	

using System.Reflection;
using System.Runtime.InteropServices;
// General information about this assembly is provided by the following
// set of attributes. Change the values of these attributes to change the information
// related to the assembly.
[assembly: AssemblyTitle("NaVeOl_Cripto")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("NaVeOl_Cripto")]
[assembly: AssemblyCopyright("Copyright © 2023 Eight To Seven | Naveol. ® 8(to)7 A Dutch company Registered IF-Depot IS BOIP Luxembourg:143627A")]
[assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]
// Setting the value to False for the ComVisible parameter makes the types in this assembly invisible
// for COM components. If you need to access a type in this assembly via
//COM, you should set the ComVisible attribute to TRUE for this type.[assembly: ComVisible(false)]
// The following GUID is used to identify the type library if this project will be visible to COM [assembly: Guid("dd8c982e-8c46-41ae-a33c-870802aefcfd")]
// The build version information consists of the following four values:
//
// Main Version Number
// Additional Version Number
// Build Number
// Revision

//
// You can set all values or accept the default build and revision numbers
// using "*", as shown below:
// [assembly: AssemblyVersion("1.0.*")] [assembly: AssemblyVersion("1.0.0.0")] [assembly: AssemblyFileVersion("1.0.0.0")]
